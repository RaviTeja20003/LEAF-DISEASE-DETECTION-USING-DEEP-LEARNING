# -*- coding: utf-8 -*-
"""LEAF DISEASE DETECTION USING DEEP LEARNING.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16P-gxwG3fJQFjT9Apk7BzNrfygaHE1IN
"""

import os 
os.environ['KAGGLE_CONFIG_DIR'] = '/content/drive/MyDrive/NEW DATA'

!kaggle datasets download -d vipoooool/new-plant-diseases-dataset

!unzip \*.zip && rm *.zip

!ls

import numpy as np
import pandas as pd
import matplotlib.pyplot as plot 
import os
import keras
from keras.preprocessing.image import ImageDataGenerator, img_to_array,load_img
from keras.applications.vgg19 import VGG19, preprocess_input,decode_predictions

# Exploaratory data analyisi
len(os.listdir("/content/new plant diseases dataset(augmented)/New Plant Diseases Dataset(Augmented)/train"))

train_data = ImageDataGenerator(zoom_range = 0.5,shear_range=0.3,horizontal_flip = True,preprocessing_function = preprocess_input)
val_data = ImageDataGenerator(preprocessing_function=preprocess_input )

train = train_data.flow_from_directory(directory="/content/new plant diseases dataset(augmented)/New Plant Diseases Dataset(Augmented)/train",
                                       target_size = (256,256), # height,width
                                       batch_size = 32) # batch size = the number of training examples in one forward/backward pass
val = val_data.flow_from_directory(directory="/content/new plant diseases dataset(augmented)/New Plant Diseases Dataset(Augmented)/valid",
                             target_size = (256,256),
                             batch_size = 32)

#MODEL

from keras.layers import Dense,Flatten  #Flatten layers are used when you got a multidimensional output and you want to make it linear to pass it onto a Dense layer
from keras.models import Model
from keras.applications.vgg19 import VGG19
import keras

base_model = VGG19(input_shape = (256,256,3),include_top = False)

for layer in base_model.layers:
  layer.trainable = False

base_model.summary()

X = Flatten()(base_model.output)
X = Dense(units = 38,activation ='softmax')(X)

# MODEL CREATION
model = Model(base_model.input, X)

model.summary()

model.compile(optimizer='adam',loss = keras.losses.categorical_crossentropy,metrics = ['accuracy'])

# EARLY STOPPING AND MODEL CHECK POINTS

from keras.callbacks import ModelCheckpoint,EarlyStopping

# early stopping 
earlystopping = EarlyStopping(monitor = 'val_accuracy',
                              min_delta = 0.01,
                              patience =3,
                              verbose=1)

# model check point 
modelcheckpoint = ModelCheckpoint(filepath ="best_model.h5",
                                  monitor ='val_accuracy',
                                  min_delta = 0.001,
                                  patience =3,
                                  verbose = 1,
                                  save_best_only = True)


call_back = [earlystopping,modelcheckpoint] # creating array, because to train a model the input is taken only as a array

his = model.fit_generator(train,
                          steps_per_epoch=16,
                          epochs = 50,
                          verbose = 1,
                          callbacks = call_back,
                          
                          validation_data= val,
                          validation_steps = 16)

h = his.history
h.keys()

import matplotlib.pyplot as plt

plt.plot(h['accuracy'],c = "red")
plt.plot(h['val_accuracy'],c = "blue")
plt.title("acc vs v-acc")
plt.show()

plt.plot(h['loss'])
plt.plot(h['val_loss'],c = "blue")
plt.title("loss vs v-loss")
plt.show()

# LOAD BEST MODEL
from keras.models import load_model
model = load_model('/content/best_model.h5')

acc = model.evaluate_generator(val)[1]
print(f"The accuracy of model is = {acc*100}%")

refer = dict(zip(list(train.class_indices.values()), list(train.class_indices.keys())))

# predict the disease 
def pred(path):

  img = load_img(path,target_size =(256,256))
  i =img_to_array(img)
  pre = preprocess_input(i)

  img = np.expand_dims(pre,axis = 0)
  predic = np.argmax(model.predict(img))
  print(f"The image belongs to = {refer[predic]}")
  print(img)



# COPY AND PASTE THE PATH OF THE LEAF AFTER UPLOADING ANY IMAGE INTO THE COLAB
path = "/content/Frogeye-spots-Botryosphaeria-obtusa-on-apple-leaf-FB.jpg"
pred(path)



